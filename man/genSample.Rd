% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/ndset.R
\name{genSample}
\alias{genSample}
\title{Generate a sample of points in dimension $p$.}
\usage{
genSample(
  p,
  n,
  range = c(1, 100),
  random = FALSE,
  sphere = TRUE,
  planes = FALSE,
  box = FALSE,
  ...
)
}
\arguments{
\item{p}{Dimension of the points.}

\item{n}{Number of samples generated.}

\item{range}{The range of the points in each dimension (a vector or matrix with \code{p} rows).}

\item{random}{Random sampling.}

\item{sphere}{Generate points on a sphere.}

\item{planes}{Generate points between two planes.}

\item{box}{Generate points in boxes.}

\item{...}{Further arguments passed on to the method for generating points. This must be done as
lists (see examples). Currently the following arguments are supported:
\itemize{
\item \code{argsPlanes}: A list of arguments for generating points between planes and in the cube
defined by the range:
\itemize{
\item \code{center}: A point between the planes (default \code{rowMeans(range)}).
\item \code{planeU}: The upper plane (default \code{c(rep(1, p), -1.2*sum(center))}).
\item \code{planeL}: The lower plane (default \code{c(rep(1, p), -0.8*sum(center))}).
}
\item \code{argsSphere}: A list of arguments for generating points on a sphere:
\itemize{
\item \code{radius}: The radius of the sphere.
\item \code{center}: The center of the sphere.
\item \code{plane}: The plane used.
\item \code{below}: Either true (generate points below the plane), false (generate points above the
plane) or \code{NULL} (generated on the whole sphere).
\item \code{factor}: If using a plane. Then the factor to multiply \code{n} with, so generate enough points
below/above the plane.
\item \code{closeToPlane}: If TRUE only return points close to the plane.
}
\item \code{argsBox}: A list of arguments for generating points inside boxes:
\itemize{
\item \code{intervals}: Number of intervals to split the length of the range into. That is, each
range is divided into \code{intervals} (sub)intervals and only the lowest/highest
subrange is used.
\item \code{cor}: How to correlate indices. If \code{'idxAlt'} then alternate the intervals (high/low)
for each dimension. For instance if \code{p = 3} and the first dimension is in the high
interval range then the second will be in the low interval range and third in the
high interval range again. If \code{idxRand} then choose the low/high interval range
for each dimension based on \code{prHigh}. If \code{idxSplit} then select
\code{floor(p/2):ceiling(p/2)} dimensions for the high interval range and the other for
the low interval range.
\item \code{prHigh}: Probability for choosing the high interval range in each dimension.
}
}}
}
\value{
A data frame with \code{p} columns
}
\description{
Generate a sample of points in dimension $p$.
}
\details{
Note having ranges with different length when using the sphere method, doesn't make
sense. The best option is properly to use a center and radius here. Moreover, as for higher
\code{p} you may have to use a larger radius than half of the desired interval range.
}
\examples{
### Using random
## p = 2
range <- matrix(c(1,100, 50,100), ncol = 2, byrow = TRUE )
pts <- genSample(2, 1000, range = range, random = TRUE)
head(pts)
Rfast::colMinsMaxs(as.matrix(pts))
plot(pts)

\donttest{
## p = 3
range <- matrix(c(1,100, 50,100, 10,50), ncol = 2, byrow = TRUE )
ini3D()
pts <- genSample(3, 1000, range = range, random = TRUE)
head(pts)
Rfast::colMinsMaxs(as.matrix(pts))
plotPoints3D(pts)
finalize3D()
}

## other p
p <- 10
range <- c(1,100)
pts <- genSample(p, 1000, range = range, random = TRUE)
head(pts)
Rfast::colMinsMaxs(as.matrix(pts))


### Using planes
## p = 2
range <- matrix(c(1,100, 50,100), ncol = 2, byrow = TRUE )
center <- rowMeans(range)
planeU <- c(rep(1, 2), -1.5*sum(rowMeans(range)))
planeL <- c(rep(1, 2), -0.7*sum(rowMeans(range)))
pts <- genSample(2, 1000, range = range, planes = TRUE,
   argsPlanes = list(center = center, planeU = planeU, planeL = planeL))
head(pts)
Rfast::colMinsMaxs(as.matrix(pts))
plot(pts)

\donttest{
## p = 3
range <- matrix(c(1,100, 50,100, 10, 50), ncol = 2, byrow = TRUE )
center <- rowMeans(range)
planeU <- c(rep(1, 3), -1.2*sum(rowMeans(range)))
planeL <- c(rep(1, 3), -0.6*sum(rowMeans(range)))
pts <- genSample(3, 1000, range = range, planes = TRUE,
   argsPlanes = list(center = center, planeU = planeU, planeL = planeL))
head(pts)
Rfast::colMinsMaxs(as.matrix(pts))
ini3D(argsPlot3d = list(box = TRUE, axes = TRUE))
plotPoints3D(pts)
rgl::planes3d(planeL[1], planeL[2], planeL[3], planeL[4], alpha = 0.5)
rgl::planes3d(planeU[1], planeU[2], planeU[3], planeU[4], alpha = 0.5)
finalize3D()
}


### Using sphere
## p = 2
range <- c(1,100)
cent <- rep(range[1] + (range[2]-range[1])/2, 2)
pts <- genSample(2, 1000, range = range)
dim(pts)
Rfast::colMinsMaxs(as.matrix(pts))
plot(pts, asp=1)
abline(sum(cent^2)/cent[1], -cent[2]/cent[1])

cent <- c(100,100)
r <- 75
planeC <- c(cent+r/3)
planeC <- c(planeC, -sum(planeC^2))
pts <- genSample(2, 100,
  argsSphere = list(center = cent, radius = r, below = FALSE, plane = planeC, factor = 6))
dim(pts)
Rfast::colMinsMaxs(as.matrix(pts))
plot(pts, asp=1)
abline(-planeC[3]/planeC[1], -planeC[2]/planeC[1])

pts <- genSample(2, 100, argsSphere = list(center = cent, radius = r, below = NULL))
dim(pts)
Rfast::colMinsMaxs(as.matrix(pts))
plot(pts, asp=1)

\donttest{
## p = 3
ini3D()
range <- c(1,100)
cent <- rep(range[1] + (range[2]-range[1])/2, 3)
pts <- genSample(3, 1000, range = range)
dim(pts)
Rfast::colMinsMaxs(as.matrix(pts))
rgl::spheres3d(cent, radius=49.5, color = "grey100", alpha=0.1)
plotPoints3D(pts)
rgl::planes3d(cent[1],cent[2],cent[3],-sum(cent^2), alpha = 0.5, col = "red")
finalize3D()

ini3D()
cent <- c(100,100,100)
r <- 75
planeC <- c(cent+r/3)
planeC <- c(planeC, -sum(planeC^2))
pts <- genSample(3, 100,
  argsSphere = list(center = cent, radius = r, below = FALSE, plane = planeC, factor = 6))
rgl::spheres3d(cent, radius=r, color = "grey100", alpha=0.1)
plotPoints3D(pts)
rgl::planes3d(planeC[1],planeC[2],planeC[3],planeC[4], alpha = 0.5, col = "red")
finalize3D()

ini3D()
pts <- genSample(3, 10000, argsSphere = list(center = cent, radius = r, below = NULL))
Rfast::colMinsMaxs(as.matrix(pts))
rgl::spheres3d(cent, radius=r, color = "grey100", alpha=0.1)
plotPoints3D(pts)
finalize3D()
}

## Other p
p <- 10
cent <- rep(0,p)
r <- 100
pts <- genSample(p, 100000, argsSphere = list(center = cent, radius = r, below = NULL))
head(pts)
Rfast::colMinsMaxs(as.matrix(pts))
apply(pts,1, function(x){sqrt(sum((x-cent)^2))}) # test should be approx. equal to radius


### Using box
## p = 2
range <- matrix(c(1,100, 50,100), ncol = 2, byrow = TRUE )
pts <- genSample(2, 1000, range = range, box = TRUE, argsBox = list(cor = "idxAlt"))
head(pts)
Rfast::colMinsMaxs(as.matrix(pts))
plot(pts)

pts <- genSample(2, 1000, range = range, box = TRUE, argsBox = list(cor = "idxAlt",
                 intervals = 6))
plot(pts)

pts <- genSample(2, 1000, range = range, box = TRUE, argsBox = list(cor = "idxRand"))
plot(pts)
pts <- genSample(2, 1000, range = range, box = TRUE,
                 argsBox = list(cor = "idxRand", prHigh = c(0.1,0.6)))
points(pts, pch = 3, col = "red")
pts <- genSample(2, 1000, range = range, box = TRUE,
                 argsBox = list(cor = "idxRand", prHigh = c(0,0)))
points(pts, pch = 4, col = "blue")

pts <- genSample(2, 1000, range = range, box = TRUE, argsBox = list(cor = "idxSplit"))
plot(pts)

\donttest{
## p = 3
range <- matrix(c(1,100, 1,200, 1,50), ncol = 2, byrow = TRUE )
ini3D(argsPlot3d = list(box = TRUE, axes = TRUE))
pts <- genSample(3, 1000, range = range, box = TRUE, , argsBox = list(cor = "idxAlt"))
head(pts)
Rfast::colMinsMaxs(as.matrix(pts))
plotPoints3D(pts)
finalize3D()

ini3D(argsPlot3d = list(box = TRUE, axes = TRUE))
pts <- genSample(3, 1000, range = range, box = TRUE, ,
                 argsBox = list(cor = "idxAlt", intervals = 6))
plotPoints3D(pts)
finalize3D()

ini3D(argsPlot3d = list(box = TRUE, axes = TRUE))
pts <- genSample(3, 1000, range = range, box = TRUE, , argsBox = list(cor = "idxRand"))
plotPoints3D(pts)
pts <- genSample(3, 1000, range = range, box = TRUE, ,
                 argsBox = list(cor = "idxRand", prHigh = c(0.1,0.6,0.1)))
plotPoints3D(pts, argsPlot3d = list(col="red"))
finalize3D()

ini3D(argsPlot3d = list(box = TRUE, axes = TRUE))
pts <- genSample(3, 1000, range = range, box = TRUE, , argsBox = list(cor = "idxSplit"))
plotPoints3D(pts)
finalize3D()
}

## other p
p <- 10
range <- c(1,100)
pts <- genSample(p, 1000, range = range, box = TRUE, argsBox = list(cor = "idxSplit"))
head(pts)
Rfast::colMinsMaxs(as.matrix(pts))
}
